AbstractMachine kernels

CONTACTS

Bug reports and suggestions go to Yanyan Jiang (jyy@nju.edu.cn) and Zihao 
Yu (yuzihao@ict.ac.cn).

# 如何生成可执行文件xx？
## 1
执行make后，创建Makefile.xx
创建Makefile.xx的内容是：
```
    NAME = bit
    SRCS = tests/bit.c
    LIBS += klib
    include /home/liuyang/Downloads/ics2022/abstract-machine/Makefile
```
定义了SRCS、LIBS变量，引入了abstract-machine/Makefile
## 2 
在abstract-machine/Makefile文件
    1 引入了abstract-machine/scripts/riscv64-nemu.mk
    2 定义了xx.elf目标
## 3 
riscv64-nemu.mk
    1 引入abstract-machine/scripts/isa/riscv64.mk、abstract-machine/scripts/platform/nemu.mk
## 4 
    abstract-machine/scripts/platform/nemu.mk 定义了run目标xx.elf
生成了
-include $(AM_HOME)/scripts/$(ARCH).mk引入了$(AM_HOME)/scripts/riscv64-nemu.mk
其又引入了$(AM_HOME)/scripts/platform/nemu.mk，这里使用xx.elf生成了xx.txt和xx.bin
执行了nemu的Makefile，参数为bin文件
最终执行riscv64-nemu-interpreter

# 结束码是如何设置的？
编译时，使用am调用bin文件，am的入口函数为_trm_init，其中调用了halt函数->nemu_trap函数，逻辑为将halt参数中的结束码放置在a0寄存器，
nemu_trap函数的汇编代码就是ebreak。所以在inst.c中ebreak指令的执行逻辑就是取出a0寄存器的值，放在nemu_state.halt_ret中，并且设置了nemu_state.state

# Makefile依赖关系
am-kernels/tests/cpu-tests/Makefile =>
    am-kernels/tests/cpu-tests/Makefile.xx <-
        abstract-machine/Makefile <- 
            abstract-machine/scripts/riscv64-nemu.mk <-
                abstract-machine/scripts/isa/riscv64.mk
                abstract-machine/scripts/platform/nemu.mk <-
                    nemu/Makefile


# native执行流程
native.mk中用g++生成可执行文件，直接调用该文件


# 调用方法
cd tests/cpu-tests
make ARCH=riscv64-nemu ALL=hello-str run

# 想要验证自己实现的这些函数时，就把这个宏打开
# define __NATIVE_USE_KLIB__
# 可以用putch输出字符串
# 在nemu menuconfig中打开DEVICE后可以用printf函数

make ARCH=native ALL=string run

cd tests/klib-tests
make ARCH=native ALL=memset run


# DEVICE的实现原理
add_mmio_map函数中传入了一个handler， 
当用户代码调用io_read时，实际调用ioe_read，执行了abstrac-machine/am/src/platform/nemu/ioe/ioe.c中对应的handler
# 测试硬件
cd tests/am-tests
make ARCH=riscv64-nemu run mainargs=t 或其他main.c


JAL 仅当rd为x1/x5，才将返回地址推送
JALR：
rd is x1/x5  rs1 is x1/x5   rd=rs1   RAS action
No                 No          —       None
No                 Yes         —        Pop
Yes                 No         —      Push
Yes                Yes        No       Pop, then push
Yes                Yes         Yes      Push
